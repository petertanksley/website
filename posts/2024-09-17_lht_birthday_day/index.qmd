---
title: "LHT #1 - Birthday Days"
description: "What day is your next birthday day?"
author:
  - name: Peter T. Tanksley
    url: https://petertanksley.github.io/
    affiliation: ALERRT Center, Texas State University
date: 09/17/24
categories: [LHT, R, dataviz] # self-defined categories
citation: 
  url: https://petertanksley.github.io/posts/2024-09-17_lht_birthday_day/ 
image: party_pineapple.png
draft: false # setting this to `true` will prevent your post from appearing on your listing page until you're ready!
---

# Birthday Days

I have a largish family. At last count, I believe I had something in the order of fifteen nieces and nephews (to give you an indication). When my girls and I drive to the family farm (yes, we have a family farm and, yes, you should be jealous because, yes, it is dope), various siblings of mine descend on the farm with their many children in-tow.

On one such occasion, a nephew of mine said a curious thing. We were discussing birthdays and he said some like "My birthday is always on Saturday or Sunday". Now, being only eight or so at the time, I suppose it is forgivable that he thought thisâ€“perhaps his last couple of birthdays were on these days and the rest were simply too far distant to remember. But it got me wondering: how do birthday days fall year-to-year?

A simple enough question, but as I thought about it I realized that I didn't know anything about the subject. I had never thought about it! Now, obviously I could have simply Google'd my way into some higher state of enlightenment. But where's the fun in that? I sensed that I had the tools in R toolkit to answer this question with logic alone (and who doesn't like going the extra mile when it means you get to play with a new puzzle?).

So, as the Joker once said: "Here. We. Go."

# To the Batcave!

(or RStudio, whatever...)

## Step one: set-up and generate some data

I'll start by loading up my favorite R packages. I pretty much always load these four packages, with the occasional addition of the {janitor} package if I'm doing some serious data cleaning.

```{r}
library(pacman)
p_load(rio, 
       tidyverse,
       tidylog)
```

Next up, generate some data! Let's see... I need to find out what day of the week a specific calendar date falls on across multiple years. So let's pick a fictitious birthday to start (can't be sharin' my real deets on the interwebs). Let's go with January 30th, 2000. Ok, how we're ready to generate some data on all of the years moving forward!

```{r}
bday_data <- tibble(year = seq(2000, 2024),
                    month = 1, 
                    day = 30)
glimpse(bday_data)
```

Sweet! We've got our basic data with repeated day/month values across years. Now, in order to move the investigation forward, we'll want to create some date columns using the {lubidate} package. This will help later on I'm sure...

```{r}
bday_data <- bday_data |> 
  mutate(bday = ymd(paste(year, month, day, sep = " ")),
         wday = wday(bday, label=TRUE))
glimpse(bday_data)
```

I added two variables. The first is a for real for real date variable ("bday"). Basically, this variable has special metadata attached to it that allows for lots of convenient calculations; it's not just a string. The second variable, "wday", was the day of the week for the date variable "bday". I chose to include labels too, and it gave me back a nicely ordered factor-esque variable (so convenient! Thank you, {lubridate}!).

## Step two: visualize the data

Having created a dataset with lots of information regarding the days of interest, let's take a look said shiny new dataset!

```{r}
bday_data |> 
  ggplot(aes(year, wday)) +
  geom_tile()
```

Cool! Ok, so there are definitely some patterns here. It looks like there are four-year stretches of consecutive days of the week for the birthday day. So, if my birthday was on a Wednesday last year, it would be Thursday this year, Friday the following year, and Saturday the year after that (assuming last year was the start of the four-year stretch)!

But the pattern is only four years long, after which it skips a day of the week, and then starts a new four year stretch. Interesting. I'm pretty sure I know what's going on, but before we sleuth any further, let's clean up this plot some.

```{r}
bday_data |> 
  ggplot(aes(year, fct_rev(wday))) + #reversed the order of the y-axis
  geom_tile(fill="dodgerblue") + #added nice color
  labs(x=element_blank(), #dropped axis titles (they're pretty obvious anyway)
       y=element_blank()) +
  theme_classic() + #picked a better theme
  coord_fixed(expand = F) #made the tiles square
```

This is nicer, but I want to avoid having tiles floating in air. Let beef up our dataset a little bit to include more than just the specific birthday we chose.

```{r}
bday_data <- bday_data |> 
  complete(year, wday)
glimpse(bday_data)


```

Ok, we filled out each year/weekday combination (the two axes of our plot). Now let's try the plot again.

```{r}
bday_data |> 
  ggplot(aes(year, wday)) +
  geom_tile(fill="dodgerblue") +
  labs(x=element_blank(),
       y=element_blank()) +
  theme_classic() +
  coord_fixed(expand = F)
```

Damn. We need to isolate our specific birthday days again. Hang on...

```{r}
bday_data |> 
  ggplot(aes(year, wday)) +
  geom_tile(aes(fill=ifelse(!is.na(day), "dodgerblue", "grey")), 
            show.legend = F,
            color="grey20") +
  labs(x=element_blank(),
       y=element_blank()) +
  theme_classic() +
  coord_fixed(expand = F) +
  scale_fill_identity() +
  scale_x_continuous(breaks = seq(2000, 2024)) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

Ok! Now we're cooking with gas! Couple things I did there. First, I used a conditional argument in the aes() call (I can't tell you how handy that trick is). Sometimes it's better to have the result of the conditional hard-coded into your dataset if its information value is high. But we're exploring here, so no biggie. Second, I adjusted the x-axis labels. I generally don't like have labels that need to be angled in order to be legible, but this is not too egregious.

## Step three: figure out the pattern!

We're so close to figuring out birthday days, I can taste the German chocolate cake (it's a huge thing in my family, just roll with it)! But did you guess what breaks up the four-year pattern of consecutive weekdays? Of course you did, you clever so-and-so, it's **leap years**! Years are not actually 365 days long; rather, they are 356.25 days long. And every four years, that .25 days adds up to a whole dollar! Or day! So, let's bring that information into our dataset and plot!

```{r}
bday_data <- bday_data |> 
  mutate(lyear = leap_year(year))
glimpse(bday_data)
```

Thanks again to the {lubridate} package (should really have made them today's sponsor...), we have a lovely logical variable "lyear" that let's us know if a specific year was a leap year. Now to update the plot!

```{r}
bday_data |> 
  ggplot(aes(year, wday)) +
  geom_tile(aes(fill=case_when((!is.na(day)) ~ "dodgerblue",
                               (is.na(day) & lyear==TRUE) ~ "brown4",
                               (is.na(day) & lyear==FALSE) ~ "grey",)), 
            show.legend = F,
            color="grey20") +
  labs(x=element_blank(),
       y=element_blank()) +
  theme_classic() +
  coord_fixed(expand = F) +
  scale_fill_identity() +
  scale_x_continuous(breaks = seq(2000, 2024)) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

Look at that plot! It says it all! Four-year consecutive birthday days, skips one day because of those dastardly leap years, and then continues on for four more blissful years of predictable birthday days. What more could you want in a plot?

(oh god, is he going to go the extra mile. he knows no one cares, right? there are no grades here, just longer blog posts that no one will ever read. oh shit, here he goes!)

## Step four (the extra mile): let's turn all of this into a function!

I'm going to fast forward a little bit through this part and keep the commentary to a minimum.

First, I'll wrap the data creation bit into a function with the data
